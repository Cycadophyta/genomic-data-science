## 4.2: Preprocessing, indexing and approximate matching
We ultimately want to solve the read alignment problem.

Naive exact matching was useful, but slow. Boyer-Moore is a fast and simple alternative.

Pigeon hole prnciple to search for approximate matches.

### Boyer-Moore
- Similar to naive exact matching
- If the matching algorithm meets a character not found in the kmer, it skips
- Matching is done in reverse along kmer
#### Bad character rule
- Upon mismatch, skip until (a) mismatch becomes a match, or (b) kmer moves past mismatched character
#### Good suffix rule
- Keep matches as matches and prevent them turning into mismatches
- For a partial match (matched suffix = t), when skipping ensure t still matches
- Shift to the next copy of t in kmer

In practice, either bad character or good suffix rule is used, _whichever skips more_.

#### Boyer-Moore Preprocessing
- Skips are pre-calculated for a given sequence 
- Pre-computed lookup tables are generated 
- eg for _P_ = TCGC:

    | |T|C|G|C|
    |-|-|-|-|-|
    |A|0|1|2|3|
    |C|0|-|0|-|
    |G|0|1|-|0|
    |T|-|0|1|2|

- a lookup table is required

### Preprocessing
- Lookup tables can be created using the pattern before the text is presented to the program.
- Lookup tables can be reused whenever the same pattern is used.
- What about preprocessing the text?
	- This can be useful when the same text is reused for different problems.
- An algorithm that preprocesses the text is called _offline_ and one that does not is called _online_.

**For example:**
- Naive exact matching is online.
- Boyer-Moore is online (only pattern is preprocessed).
- A search engine is offline.
- The read alignment problem is offline.

### Indexing
- For the read alignment problem, lots of different patterns will need to be mapped onto a single text. This text requires preprocessing by an offline algorithm.
- Examples:
	- If the text is a book, it can be preprocessed in an index.
	- Items in a supermarket are grouped.
- To index a genome, it must first be broken down into substrings (kmers) of length _k_, which are ordered alphabetically and the position(s) recorded.
- The index can then be queried by searching for the first _k_ characters in the index.
- Verification is then needed to find a match. The next positions are searched for the next characters of the pattern.
- This kind of index is called a multimap.

#### Ordered structures for indexing
- In an index, kmers and positions are stored as key-value pairs. These can then be ordered alphabetically in a multimap.
- The index can be queried by binary search (cut index in half and drop half that doesn't contain kmer recursively).
	- Query O = log<sub>2</sub>(n)

#### Hash tables for indexing
- Start with an array of empty buckets. 
- Hash function _h_ maps kmers into buckets.
- Each bucket contains a list of the kmer, position and a null value.
- There are more kmers than buckets, so some kmers end up in the same buckets (this is the pigeonhole principle). This causes a collision which can slow down the algorithm.
- Hash tables are very easy to implement in python because the dictionary is a hash table. 
- The details are hidden -- we don't know which hash function is being used or how many elements are in the hash table.

### Practical 
[2.02_SubstringIndex.ipynb](https://github.com/BenLangmead/ads1-notebooks/blob/master/2.02_SubstringIndex.ipynb)

### Kmer index variations
- Previously, our kmer index included all the kmers from _T_.
- We could, instead, take every other kmer.
- This makes the index much smaller and faster to query.
- If a kmer is not found in the index, the next kmer in the pattern should be queried
	- Both odd and even kmers in _P_ must be tested.
- Alternatively, the index could be built from every third or fourth kmer.
	- This means that three or four kmers in the pattern need to be queried.

#### Subsequences
- Instead of building an idex from substrings, subsequences can be used. 
	- Subsequences are strings of characters in the sequence, but not necessarily one after the other (characters can be skipped).
- The same 'shape' must be used for each item of the index.
- The advantage of this is that it increases specificity of the index hits. Index hits are more likely to lead to a match.
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE4NjAzMTkyNjUsNzE0MTcwNzg3LDcwMT
EyODIzNCwyMzgxNTQzMzQsLTQxNTY4NzEyNywtMTQ0NzI0NzI2
NCwtMTUzMDU4NzM5OSwxNzg1NDQ2NTkwLDE3NDA2MzYxNzksMT
c4MjM0ODUxNl19
-->