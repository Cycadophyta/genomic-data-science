## 4.2: Preprocessing, indexing and approximate matching

Naive exact matching was useful, but slow. Boyer-Moore is a fast and simple alternative.

Pigeon hole prnciple to search for approximate matches.

### Boyer-Moore
- Similar to naive exact matching
- If the matching algorithm meets a character not found in the kmer, it skips
- Matching is done in reverse along kmer
#### Bad character rule
- Upon mismatch, skip until (a) mismatch becomes a match, or (b) kmer moves past mismatched character
#### Good suffix rule
- Keep matches as matches and prevent them turning into mismatches
- For a partial match (matched suffix = t), when skipping ensure t still matches
- Shift to the next copy of t in kmer

In practice, either bad character or good suffix rule is used, _whichever skips more_.

#### Boyer-Moore Preprocessing
- Skips are pre-calculated for a given sequence 
- Pre-computed lookup tables are generated 
- eg for _P_ = TCGC:

    | |T|C|G|C|
    |-|-|-|-|-|
    |A|0|1|2|3|
    |C|0|-|0|-|
    |G|0|1|-|0|
    |T|-|0|1|2|

- a lookup table is required

### Preprocessing
- Lookup tables can be created using the pattern before the text is presented to the program.
- Lookup tables can be reused whenever the same pattern is used.
- What about preprocessing the text?
	- This can be useful when the same text is reused for different problems.
- An algorithm that preprocesses the text is called _offline_ and one that does not is called _online_.

**For example:**
- Naive exact matching is online.
- Boyer-Moore is online (only pattern is preprocessed).
- A search engine
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEzMTYwNTU4NTRdfQ==
-->