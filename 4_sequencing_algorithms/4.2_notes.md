## 4.2: Preprocessing, indexing and approximate matching
We ultimately want to solve the read alignment problem.

Naive exact matching was useful, but slow. Boyer-Moore is a fast and simple alternative.

Pigeon hole prnciple to search for approximate matches.

### Boyer-Moore
- Similar to naive exact matching
- If the matching algorithm meets a character not found in the kmer, it skips
- Matching is done in reverse along kmer
#### Bad character rule
- Upon mismatch, skip until (a) mismatch becomes a match, or (b) kmer moves past mismatched character
#### Good suffix rule
- Keep matches as matches and prevent them turning into mismatches
- For a partial match (matched suffix = t), when skipping ensure t still matches
- Shift to the next copy of t in kmer

In practice, either bad character or good suffix rule is used, _whichever skips more_.

#### Boyer-Moore Preprocessing
- Skips are pre-calculated for a given sequence 
- Pre-computed lookup tables are generated 
- eg for _P_ = TCGC:

    | |T|C|G|C|
    |-|-|-|-|-|
    |A|0|1|2|3|
    |C|0|-|0|-|
    |G|0|1|-|0|
    |T|-|0|1|2|

- a lookup table is required

### Preprocessing
- Lookup tables can be created using the pattern before the text is presented to the program.
- Lookup tables can be reused whenever the same pattern is used.
- What about preprocessing the text?
	- This can be useful when the same text is reused for different problems.
- An algorithm that preprocesses the text is called _offline_ and one that does not is called _online_.

**For example:**
- Naive exact matching is online.
- Boyer-Moore is online (only pattern is preprocessed).
- A search engine is offline.
- The read alignment problem is offline.

### Indexing
- For the read alignment problem, lots of different patterns will need to be mapped onto a single text. This text requires preprocessing by an offline algorithm.
- Examples:
	- If the text is a book, it can be preprocessed in an index.
	- Items in a supermarket are grouped.
- To index a genome, it must first be broken down into substrings (kmers) of length _k_, which are ordered alphabetically and the position(s) recorded.
- The index can then be queried by searching for the first _k_ characters in the index.
- Verification is then needed to find a match. The next positions are searched for the next characters of the pattern.
- This kind of index is called a multimap.

#### Ordered structures for indexing
- In an index, kmers and positions are stored as key-value pairs. These can then be ordered alphabetically.
- The index can be queried by binary search (cut index in half and drop half that doesn't contain kmer recursively).
	- Query O = log2(n)

<!--stackedit_data:
eyJoaXN0b3J5IjpbOTYzMjQ2NDEsMTc4NTQ0NjU5MCwxNzQwNj
M2MTc5LDE3ODIzNDg1MTZdfQ==
-->